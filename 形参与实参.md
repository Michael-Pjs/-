# C/C++中的实参和形参 
- 我觉得只要明白了值传递和地址传递，就应该能明白形参和实参的具体工作细节了。
1. 值传递
   - 实参是变量，表达式等值。
   - find（int x）{}
   - y= find(z)；
   - 上面的例子中，z是实参，x是形参。x变z不变。
   - 在值传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在值传递过程中，形参的变化不会对实参有任何的影响。
2. 地址传递（也称引用传递）
   - 实参是指针。
   - 在函数调用的时候，实参传递给你的是指针地址，地址一样也就意味着实参和形参是一样的，当你的形参发生改变时，实参也会发生改变。
   - find（int  &x）{}
   -  y= find(z)；
   - 上面的例子中，z是实参，x是形参。z随x而改变。
3. const引用传递
   - find（const int  &x）{}
   - y= find(z)；
   - 上面的例子中，z是实参，x是形参。z不随x而改变。
   - 有人就会问了，你这样做不是和值传递一样的么？NO！
   - 仔细观察就会发现，在值传递中要进行两次拷贝，浪费内存资源是相当可耻的，const的出现有效避免了这种情况的出现，只需拷贝一次就够了。
   - [摘自https://www.cnblogs.com/kane0526/p/3913284.html](https://www.cnblogs.com/kane0526/p/3913284.html)
# 实参和形参的区别
1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值。
3. 实参和形参在数量上，类型上、顺序上应严格一致，否则就会发生类型不匹配的错误。
4. 在一般传值调用的机制中只能把实参传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参值发生改变，而实参中的值不会变化。而在引用调用的机制当中是将实参引用的地址传递给了形参，所以任何发生在形参上的改变实际上也发生在实参变量上。 
- [摘自https://zhidao.baidu.com/question/339722896.html](https://zhidao.baidu.com/question/339722896.html)
